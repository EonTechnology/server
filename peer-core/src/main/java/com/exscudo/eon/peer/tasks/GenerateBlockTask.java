package com.exscudo.eon.peer.tasks;

import java.util.HashMap;
import java.util.Map;

import com.exscudo.eon.SecretPhraseProvider;
import com.exscudo.eon.peer.Constant;
import com.exscudo.eon.peer.ExecutionContext;
import com.exscudo.eon.peer.TimeProvider;
import com.exscudo.eon.peer.data.Block;
import com.exscudo.eon.peer.data.DatastoreConnector;
import com.exscudo.eon.peer.data.DatastoreConnector.TransactionMapper;
import com.exscudo.eon.peer.data.Transaction;
import com.exscudo.eon.peer.data.UnitOfWork;
import com.exscudo.eon.peer.exceptions.UnknownObjectException;
import com.exscudo.eon.utils.Format;
import com.exscudo.eon.utils.Loggers;

/**
 * Try to create a new block.
 *
 */
public final class GenerateBlockTask extends AbstractTask implements Runnable {
	private boolean useFastGeneration = false;
	private final DatastoreConnector target;

	public GenerateBlockTask(ExecutionContext context, DatastoreConnector target) {
		super(context);

		this.target = target;
	}

	public boolean isUseFastGeneration() {
		return useFastGeneration;
	}

	public void setUseFastGeneration(boolean useFastGeneration) {
		this.useFastGeneration = useFastGeneration;
	}

	@Override
	public void run() {

		if (useFastGeneration) {
			((AsyncState) context.state()).creator.start();
		}

		if (!((AsyncState) context.state()).creator.isStarted()) {
			return;
		}

		// 1. The blocks is synchronized with at least one node.
		// 2. Enabled "fast generation" mode

		try {

			int elapsedTime = 0;

			do {

				Block lastBlock = target.blocks().getLastBlock();

				// Gives the opportunity to generate the best last block.
				//
				Block lastCreatedBlock = ((AsyncState) context.state()).creator.lastGeneratedBlock;
				if (lastCreatedBlock == null || lastCreatedBlock.getHeight() < lastBlock.getHeight() - 1) {
					lastCreatedBlock = lastBlock;
				}

				elapsedTime = TimeProvider.getEpochTime() - lastCreatedBlock.getTimestamp();
				if (elapsedTime > Constant.BLOCK_PERIOD || lastBlock.getID() == target.blocks().getGenesisBlockID()) {

					// New block creating...
					Loggers.VERBOSE.info(GenerateBlockTask.class, "Creating new block...");

					Block newBlock = target.createNextBlock(lastCreatedBlock, SecretPhraseProvider.getSecretPhrase());

					synchronized (target.blocks().syncObject()) {
						lastBlock = target.blocks().getLastBlock();

						try {

							// The last blocks of the chain were removed after
							// the last GenerateBlockTask was finished
							if (lastBlock.getHeight() < lastCreatedBlock.getHeight()) {

								Loggers.NOTICE.warning(GenerateBlockTask.class,
										"Illegal state. lastCreatedBlock.getHeight() > lastBlock.getHeight().");
								return;

							}

							// Added a new block after the resolution of the
							// generation. Trying to create a new unit with
							// greater Difficulty.
							while (lastBlock.getHeight() > lastCreatedBlock.getHeight()) {

								lastBlock = target.blocks().getBlock(lastBlock.getPreviousBlock());

							}
							// Fixing the last block generated by the node.
							((AsyncState) context.state()).creator.lastGeneratedBlock = newBlock;

							// Trying to add a new block to the end of the
							// chain.
							Loggers.VERBOSE.info(GenerateBlockTask.class,
									"Adding new block [{}] {}. Previous block [{}]{}", newBlock.getHeight(),
									Format.BlockIdEncode(newBlock.getID()), lastBlock.getHeight(),
									Format.BlockIdEncode(lastBlock.getID()));

							if (lastBlock.getPreviousBlock() == newBlock.getPreviousBlock() && newBlock
									.getCumulativeDifficulty().compareTo(lastBlock.getCumulativeDifficulty()) > 0) {

								((AsyncState) context.state()).creator.stop();
								synchronized (target.transactions().syncObject()) {

									final TransactionMapper mapper = target.transactions();
									Map<Long, Transaction> txMap = new HashMap<Long, Transaction>();
									long[] transactionIds = newBlock.getTransactions();
									for (int i = 0; i < transactionIds.length; i++) {

										Transaction tx = mapper.unconfirmed().get(transactionIds[i]);
										if (tx == null) {
											tx = mapper.confirmed().get(transactionIds[i]);
											if (tx == null) {
												throw new UnknownObjectException(
														Format.TransactionIdEncode(transactionIds[i]));
											}
										}
										txMap.put(transactionIds[i], tx);
									}

									// A block with the best cumulative
									// difficulty has been created.
									// The last block in the chain will be
									// replaced.
									UnitOfWork uow = target.createUnitOfWork(GenerateBlockTask.class.getName());
									try {

										long lastBlockID = target.blocks().getLastBlockID();
										long commonBlockID = newBlock.getPreviousBlock();

										target.popTo(commonBlockID);
										if (lastBlockID != newBlock.getPreviousBlock()) {

											throw new IllegalStateException("Unexpected block. Expected - "
													+ Format.BlockIdEncode(commonBlockID) + ", current - "
													+ Format.BlockIdEncode(lastBlockID));

										}

										target.pushBlock(newBlock, txMap);

										uow.apply();

									} catch (Exception e) {
										uow.restore();
										throw e;
									}

								}

							} else if (((AsyncState) context.state()).creator.isStarted()
									&& target.blocks().getLastBlockID() == newBlock.getPreviousBlock()) {

								((AsyncState) context.state()).creator.stop();
								synchronized (target.transactions().syncObject()) {

									final TransactionMapper mapper = target.transactions();
									Map<Long, Transaction> txMap = new HashMap<Long, Transaction>();
									long[] transactionIds = newBlock.getTransactions();
									for (int i = 0; i < transactionIds.length; i++) {

										Transaction tx = mapper.unconfirmed().get(transactionIds[i]);
										if (tx == null) {
											throw new UnknownObjectException(
													Format.TransactionIdEncode(transactionIds[i]));
										}
										txMap.put(transactionIds[i], tx);
									}

									UnitOfWork uow = target.createUnitOfWork(GenerateBlockTask.class.getName());
									try {

										target.pushBlock(newBlock, txMap);
										uow.apply();

									} catch (Exception e) {
										uow.restore();
										throw e;
									}

								}

							} else {

								// Could not create block with better cumulative
								// difficulty.
								Loggers.VERBOSE.info(GenerateBlockTask.class,
										"Unable to add new block. Illegal state.");

							}

						} catch (UnknownObjectException e) {

							// An exception is thrown if no transaction is
							// found. (e.g., an expired transaction was
							// deleted)
							Loggers.VERBOSE.info(GenerateBlockTask.class, "Unable to add new block.", e);

						}

					}
				}

			} while (useFastGeneration && elapsedTime > Constant.BLOCK_PERIOD);

		} catch (Exception e) {

			Loggers.NOTICE.error(GenerateBlockTask.class, e);

		}
	}

}