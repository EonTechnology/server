package com.exscudo.peer.core.importer.tasks;

import com.exscudo.peer.core.Constant;
import com.exscudo.peer.core.api.Difficulty;
import com.exscudo.peer.core.blockchain.BlockchainService;
import com.exscudo.peer.core.blockchain.events.BlockEventManager;
import com.exscudo.peer.core.common.Loggers;
import com.exscudo.peer.core.common.TimeProvider;
import com.exscudo.peer.core.common.exceptions.ValidateException;
import com.exscudo.peer.core.data.Block;
import com.exscudo.peer.core.importer.BlockGenerator;
import com.exscudo.peer.core.importer.IFork;
import com.exscudo.peer.core.importer.IUnitOfWork;
import com.exscudo.peer.core.importer.UnitOfWork;
import com.exscudo.peer.core.ledger.LedgerProvider;

/**
 * Try to create a new block.
 * <p>
 * An attempt is made to generate a new ending for a chain of blocks. If a block
 * with highest difficulty was generated, then it is added to the end of chain.
 */
public final class GenerateBlockTask implements Runnable {

    private final BlockGenerator generator;
    private final IFork fork;
    private final TimeProvider timeProvider;
    private final BlockEventManager blockEventManager;
    /**
     * The last block generated by the node.
     */
    private volatile Block lastGeneratedBlock = null;
    private BlockchainService blockchainService;
    private LedgerProvider ledgerProvider;

    public GenerateBlockTask(IFork fork,
                             BlockGenerator generator,
                             TimeProvider timeProvider,
                             LedgerProvider ledgerProvider,
                             BlockEventManager blockEventManager,
                             BlockchainService blockchainService) {

        this.generator = generator;
        this.ledgerProvider = ledgerProvider;
        this.blockchainService = blockchainService;
        this.fork = fork;
        this.timeProvider = timeProvider;
        this.blockEventManager = blockEventManager;
    }

    @Override
    public void run() {

        try {

            if (!generator.isInitialized()) {
                // Generation at a node can be switched off...
                return;
            }

            Block lastBlock = blockchainService.getLastBlock();

            // Gives the opportunity to generate the best last block.
            Block lastCreatedBlock = lastGeneratedBlock;
            if (lastCreatedBlock == null || lastCreatedBlock.getHeight() == lastBlock.getHeight()) {
                lastCreatedBlock = lastBlock;
            } else {
                lastCreatedBlock = blockchainService.getBlock(lastBlock.getPreviousBlock());
            }

            if (fork.isPassed(lastCreatedBlock.getTimestamp() + Constant.BLOCK_PERIOD)) {
                return;
            }

            int elapsedTime = timeProvider.get() - lastCreatedBlock.getTimestamp();
            if (elapsedTime > Constant.BLOCK_PERIOD) {

                // New block creating...
                Block newBlock = generator.createNextBlock(lastCreatedBlock);
                if (newBlock == null) {
                    Loggers.warning(GenerateBlockTask.class, "Unable to create new block.");
                    return;
                }

                // The last blocks of the chain were removed after the block
                // creating was started.
                lastBlock = blockchainService.getLastBlock();
                if (lastBlock.getHeight() < lastCreatedBlock.getHeight()) {

                    Loggers.info(GenerateBlockTask.class,
                                 "Illegal state. lastCreatedBlock.getHeight() > lastBlock.getHeight().");
                    return;
                }

                // Fixing the last block generated by the node.
                lastGeneratedBlock = newBlock;

                // Trying to add a new block to the end of the chain.
                Loggers.info(GenerateBlockTask.class,
                             "Adding new block [{}] {}. Previous block [{}]{}",
                             newBlock.getHeight(),
                             newBlock.getID(),
                             lastBlock.getHeight(),
                             lastBlock.getID());

                Difficulty currentState = new Difficulty(lastBlock);
                Difficulty newState = new Difficulty(newBlock);
                if (newState.compareTo(currentState) > 0) {

                    blockEventManager.raiseBeforeChanging(this, lastCreatedBlock);
                    IUnitOfWork uow = new UnitOfWork(blockchainService, ledgerProvider, fork, lastCreatedBlock);
                    try {

                        uow.pushBlock(newBlock);
                        Block newHead = uow.commit();
                        if (newHead != null) {
                            blockEventManager.raiseLastBlockChanged(this, newHead);
                        }
                    } catch (ValidateException e) {

                        Loggers.info(GenerateBlockTask.class, "Unable to add new block.", e);
                    } catch (Exception e) {

                        throw e;
                    }
                } else {
                    // Could not create block with better cumulative
                    // difficulty.
                    Loggers.info(GenerateBlockTask.class, "Unable to add new block. Illegal state.");
                }
            }
        } catch (Exception e) {
            Loggers.error(GenerateBlockTask.class, e);
        }
    }
}