package com.exscudo.peer.core.importer.tasks;

import com.exscudo.peer.core.Constant;
import com.exscudo.peer.core.IFork;
import com.exscudo.peer.core.api.Difficulty;
import com.exscudo.peer.core.blockchain.BlockchainProvider;
import com.exscudo.peer.core.blockchain.ITransactionMapper;
import com.exscudo.peer.core.common.IAccountHelper;
import com.exscudo.peer.core.common.ITimeProvider;
import com.exscudo.peer.core.common.ITransactionEstimator;
import com.exscudo.peer.core.common.Loggers;
import com.exscudo.peer.core.common.exceptions.ValidateException;
import com.exscudo.peer.core.data.Block;
import com.exscudo.peer.core.importer.BlockGenerator;
import com.exscudo.peer.core.importer.IUnitOfWork;
import com.exscudo.peer.core.importer.UnitOfWork;
import com.exscudo.peer.core.ledger.LedgerProvider;
import com.exscudo.peer.core.middleware.TransactionValidatorFabric;

/**
 * Try to create a new block.
 * <p>
 * An attempt is made to generate a new ending for a chain of blocks. If a block
 * with highest difficulty was generated, then it is added to the end of chain.
 */
public final class GenerateBlockTask implements Runnable {

    private final BlockGenerator generator;
    private final IFork fork;
    private final ITimeProvider timeProvider;
    private final TransactionValidatorFabric transactionValidatorFabric;
    private final ITransactionEstimator estimator;
    private final IAccountHelper accountHelper;
    private final ITransactionMapper transactionMapper;

    /**
     * The last block generated by the node.
     */
    private volatile Block lastGeneratedBlock = null;
    private BlockchainProvider blockchainProvider;
    private LedgerProvider ledgerProvider;

    public GenerateBlockTask(IFork fork,
                             BlockGenerator generator,
                             ITimeProvider timeProvider,
                             LedgerProvider ledgerProvider,
                             BlockchainProvider blockchainProvider,
                             TransactionValidatorFabric transactionValidatorFabric,
                             ITransactionEstimator estimator,
                             IAccountHelper accountHelper,
                             ITransactionMapper transactionMapper) {

        this.generator = generator;
        this.ledgerProvider = ledgerProvider;
        this.blockchainProvider = blockchainProvider;
        this.fork = fork;
        this.timeProvider = timeProvider;
        this.transactionValidatorFabric = transactionValidatorFabric;
        this.estimator = estimator;
        this.accountHelper = accountHelper;
        this.transactionMapper = transactionMapper;
    }

    @Override
    public void run() {

        try {

            if (!generator.isInitialized()) {
                // Generation at a node can be switched off...
                return;
            }

            Block lastBlock = blockchainProvider.getLastBlock();

            // Gives the opportunity to generate the best last block.
            Block lastCreatedBlock = lastGeneratedBlock;
            if (lastCreatedBlock == null || lastCreatedBlock.getHeight() == lastBlock.getHeight()) {
                lastCreatedBlock = lastBlock;
            } else {
                lastCreatedBlock = blockchainProvider.getBlock(lastBlock.getPreviousBlock());
            }

            if (fork.isPassed(lastCreatedBlock.getTimestamp() + Constant.BLOCK_PERIOD)) {
                return;
            }

            int elapsedTime = timeProvider.get() - lastCreatedBlock.getTimestamp();
            if (elapsedTime > Constant.BLOCK_PERIOD) {

                // New block creating...
                Block newBlock = generator.createNextBlock(lastCreatedBlock);
                if (newBlock == null) {
                    Loggers.warning(GenerateBlockTask.class, "Unable to create new block.");
                    return;
                }

                // The last blocks of the chain were removed after the block
                // creating was started.
                lastBlock = blockchainProvider.getLastBlock();
                if (lastBlock.getHeight() < lastCreatedBlock.getHeight()) {

                    Loggers.info(GenerateBlockTask.class,
                                 "Illegal state. lastCreatedBlock.getHeight() > lastBlock.getHeight().");
                    return;
                }

                // Fixing the last block generated by the node.
                lastGeneratedBlock = newBlock;

                // Trying to add a new block to the end of the chain.
                Loggers.info(GenerateBlockTask.class,
                             "Adding new block [{}] {}. Previous block [{}]{}",
                             newBlock.getHeight(),
                             newBlock.getID(),
                             lastBlock.getHeight(),
                             lastBlock.getID());

                Difficulty currentState = new Difficulty(lastBlock);
                Difficulty newState = new Difficulty(newBlock);
                if (newState.compareTo(currentState) > 0) {

                    IUnitOfWork uow = new UnitOfWork(blockchainProvider,
                                                     ledgerProvider,
                                                     fork,
                                                     lastCreatedBlock,
                                                     transactionValidatorFabric,
                                                     estimator,
                                                     accountHelper,
                                                     transactionMapper);
                    try {

                        uow.pushBlock(newBlock);
                        uow.commit();
                    } catch (ValidateException e) {

                        Loggers.info(GenerateBlockTask.class, "Unable to add new block.", e);
                    } catch (Exception e) {

                        throw e;
                    }
                } else {
                    Loggers.info(GenerateBlockTask.class, "Could not create block with better cumulative difficulty.");
                }
            }
        } catch (Exception e) {
            Loggers.error(GenerateBlockTask.class, e);
        }
    }
}