package org.eontechnology.and.peer.core.importer.tasks;

import org.eontechnology.and.peer.core.IFork;
import org.eontechnology.and.peer.core.api.Difficulty;
import org.eontechnology.and.peer.core.blockchain.BlockchainProvider;
import org.eontechnology.and.peer.core.blockchain.ITransactionMapper;
import org.eontechnology.and.peer.core.common.IAccountHelper;
import org.eontechnology.and.peer.core.common.ITimeProvider;
import org.eontechnology.and.peer.core.common.ITransactionEstimator;
import org.eontechnology.and.peer.core.common.Loggers;
import org.eontechnology.and.peer.core.common.exceptions.ValidateException;
import org.eontechnology.and.peer.core.data.Block;
import org.eontechnology.and.peer.core.importer.BlockGenerator;
import org.eontechnology.and.peer.core.importer.IUnitOfWork;
import org.eontechnology.and.peer.core.importer.UnitOfWork;
import org.eontechnology.and.peer.core.ledger.LedgerProvider;
import org.eontechnology.and.peer.core.middleware.TransactionValidatorFabric;

/**
 * Try to create a new block.
 *
 * <p>An attempt is made to generate a new ending for a chain of blocks. If a block with highest
 * difficulty was generated, then it is added to the end of chain.
 */
public final class GenerateBlockTask implements Runnable {

  private final BlockGenerator generator;
  private final IFork fork;
  private final ITimeProvider timeProvider;
  private final TransactionValidatorFabric transactionValidatorFabric;
  private final ITransactionEstimator estimator;
  private final IAccountHelper accountHelper;
  private final ITransactionMapper transactionMapper;

  /** The last block generated by the node. */
  private volatile Block lastGeneratedBlock = null;

  private BlockchainProvider blockchainProvider;
  private LedgerProvider ledgerProvider;

  public GenerateBlockTask(
      IFork fork,
      BlockGenerator generator,
      ITimeProvider timeProvider,
      LedgerProvider ledgerProvider,
      BlockchainProvider blockchainProvider,
      TransactionValidatorFabric transactionValidatorFabric,
      ITransactionEstimator estimator,
      IAccountHelper accountHelper,
      ITransactionMapper transactionMapper) {

    this.generator = generator;
    this.ledgerProvider = ledgerProvider;
    this.blockchainProvider = blockchainProvider;
    this.fork = fork;
    this.timeProvider = timeProvider;
    this.transactionValidatorFabric = transactionValidatorFabric;
    this.estimator = estimator;
    this.accountHelper = accountHelper;
    this.transactionMapper = transactionMapper;
  }

  @Override
  public void run() {

    try {

      if (!generator.isInitialized()) {
        // Generation at a node can be switched off...
        return;
      }

      Block lastBlock = blockchainProvider.getLastBlock();

      // Gives the opportunity to generate the best last block.
      Block lastCreatedBlock = lastGeneratedBlock;
      if (lastCreatedBlock == null || lastCreatedBlock.getHeight() == lastBlock.getHeight()) {
        lastCreatedBlock = lastBlock;
      } else {
        lastCreatedBlock = blockchainProvider.getBlock(lastBlock.getPreviousBlock());
      }

      if (fork.isPassed(fork.getNextBlockTimestamp(lastCreatedBlock.getTimestamp()))) {
        return;
      }

      if (timeProvider.get() > fork.getNextBlockTimestamp(lastCreatedBlock.getTimestamp())) {

        // New block creating...
        Block newBlock = generator.createNextBlock(lastCreatedBlock);
        if (newBlock == null) {
          Loggers.warning(GenerateBlockTask.class, "Unable to create new block.");
          return;
        }

        // The last blocks of the chain were removed after the block
        // creating was started.
        lastBlock = blockchainProvider.getLastBlock();
        if (lastBlock.getHeight() < lastCreatedBlock.getHeight()) {

          Loggers.info(
              GenerateBlockTask.class,
              "Illegal state. lastCreatedBlock.getHeight() > lastBlock.getHeight().");
          return;
        }

        // Fixing the last block generated by the node.
        lastGeneratedBlock = newBlock;

        // Trying to add a new block to the end of the chain.
        Loggers.info(
            GenerateBlockTask.class,
            "Adding new block [{}] {}. Previous block [{}]{}",
            newBlock.getHeight(),
            newBlock.getID(),
            lastBlock.getHeight(),
            lastBlock.getID());

        Difficulty currentState = new Difficulty(lastBlock);
        Difficulty newState = new Difficulty(newBlock);
        if (newState.compareTo(currentState) > 0) {

          IUnitOfWork uow =
              new UnitOfWork(
                  blockchainProvider,
                  ledgerProvider,
                  fork,
                  lastCreatedBlock,
                  transactionValidatorFabric,
                  estimator,
                  accountHelper,
                  transactionMapper);
          try {

            uow.pushBlock(newBlock);
            uow.commit();
          } catch (ValidateException e) {

            Loggers.info(GenerateBlockTask.class, "Unable to add new block.", e);
          } catch (Exception e) {

            throw e;
          }
        } else {
          Loggers.info(
              GenerateBlockTask.class, "Could not create block with better cumulative difficulty.");
        }
      }
    } catch (Exception e) {
      Loggers.error(GenerateBlockTask.class, e);
    }
  }
}
